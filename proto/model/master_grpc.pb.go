// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package model

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// EmployeeServiceClient is the client API for EmployeeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EmployeeServiceClient interface {
	GetEmployees(ctx context.Context, in *Tokens, opts ...grpc.CallOption) (*Employees, error)
	CreateEmployee(ctx context.Context, in *AddEmployee, opts ...grpc.CallOption) (*ResponseAddEmployee, error)
}

type employeeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEmployeeServiceClient(cc grpc.ClientConnInterface) EmployeeServiceClient {
	return &employeeServiceClient{cc}
}

func (c *employeeServiceClient) GetEmployees(ctx context.Context, in *Tokens, opts ...grpc.CallOption) (*Employees, error) {
	out := new(Employees)
	err := c.cc.Invoke(ctx, "/model.EmployeeService/GetEmployees", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *employeeServiceClient) CreateEmployee(ctx context.Context, in *AddEmployee, opts ...grpc.CallOption) (*ResponseAddEmployee, error) {
	out := new(ResponseAddEmployee)
	err := c.cc.Invoke(ctx, "/model.EmployeeService/CreateEmployee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EmployeeServiceServer is the server API for EmployeeService service.
// All implementations must embed UnimplementedEmployeeServiceServer
// for forward compatibility
type EmployeeServiceServer interface {
	GetEmployees(context.Context, *Tokens) (*Employees, error)
	CreateEmployee(context.Context, *AddEmployee) (*ResponseAddEmployee, error)
	mustEmbedUnimplementedEmployeeServiceServer()
}

// UnimplementedEmployeeServiceServer must be embedded to have forward compatible implementations.
type UnimplementedEmployeeServiceServer struct {
}

func (UnimplementedEmployeeServiceServer) GetEmployees(context.Context, *Tokens) (*Employees, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEmployees not implemented")
}
func (UnimplementedEmployeeServiceServer) CreateEmployee(context.Context, *AddEmployee) (*ResponseAddEmployee, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateEmployee not implemented")
}
func (UnimplementedEmployeeServiceServer) mustEmbedUnimplementedEmployeeServiceServer() {}

// UnsafeEmployeeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EmployeeServiceServer will
// result in compilation errors.
type UnsafeEmployeeServiceServer interface {
	mustEmbedUnimplementedEmployeeServiceServer()
}

func RegisterEmployeeServiceServer(s grpc.ServiceRegistrar, srv EmployeeServiceServer) {
	s.RegisterService(&_EmployeeService_serviceDesc, srv)
}

func _EmployeeService_GetEmployees_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tokens)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmployeeServiceServer).GetEmployees(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.EmployeeService/GetEmployees",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmployeeServiceServer).GetEmployees(ctx, req.(*Tokens))
	}
	return interceptor(ctx, in, info, handler)
}

func _EmployeeService_CreateEmployee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddEmployee)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EmployeeServiceServer).CreateEmployee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.EmployeeService/CreateEmployee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EmployeeServiceServer).CreateEmployee(ctx, req.(*AddEmployee))
	}
	return interceptor(ctx, in, info, handler)
}

var _EmployeeService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "model.EmployeeService",
	HandlerType: (*EmployeeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetEmployees",
			Handler:    _EmployeeService_GetEmployees_Handler,
		},
		{
			MethodName: "CreateEmployee",
			Handler:    _EmployeeService_CreateEmployee_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "master.proto",
}

// JobServiceClient is the client API for JobService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type JobServiceClient interface {
	GetAllJob(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*JobList, error)
	AddJob(ctx context.Context, in *Job, opts ...grpc.CallOption) (*Response, error)
	GetByIdJob(ctx context.Context, in *JobId, opts ...grpc.CallOption) (*Jobs, error)
}

type jobServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewJobServiceClient(cc grpc.ClientConnInterface) JobServiceClient {
	return &jobServiceClient{cc}
}

func (c *jobServiceClient) GetAllJob(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*JobList, error) {
	out := new(JobList)
	err := c.cc.Invoke(ctx, "/model.JobService/GetAllJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) AddJob(ctx context.Context, in *Job, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/model.JobService/AddJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) GetByIdJob(ctx context.Context, in *JobId, opts ...grpc.CallOption) (*Jobs, error) {
	out := new(Jobs)
	err := c.cc.Invoke(ctx, "/model.JobService/GetByIdJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JobServiceServer is the server API for JobService service.
// All implementations must embed UnimplementedJobServiceServer
// for forward compatibility
type JobServiceServer interface {
	GetAllJob(context.Context, *Empty) (*JobList, error)
	AddJob(context.Context, *Job) (*Response, error)
	GetByIdJob(context.Context, *JobId) (*Jobs, error)
	mustEmbedUnimplementedJobServiceServer()
}

// UnimplementedJobServiceServer must be embedded to have forward compatible implementations.
type UnimplementedJobServiceServer struct {
}

func (UnimplementedJobServiceServer) GetAllJob(context.Context, *Empty) (*JobList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllJob not implemented")
}
func (UnimplementedJobServiceServer) AddJob(context.Context, *Job) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddJob not implemented")
}
func (UnimplementedJobServiceServer) GetByIdJob(context.Context, *JobId) (*Jobs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByIdJob not implemented")
}
func (UnimplementedJobServiceServer) mustEmbedUnimplementedJobServiceServer() {}

// UnsafeJobServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JobServiceServer will
// result in compilation errors.
type UnsafeJobServiceServer interface {
	mustEmbedUnimplementedJobServiceServer()
}

func RegisterJobServiceServer(s grpc.ServiceRegistrar, srv JobServiceServer) {
	s.RegisterService(&_JobService_serviceDesc, srv)
}

func _JobService_GetAllJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).GetAllJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.JobService/GetAllJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).GetAllJob(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_AddJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Job)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).AddJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.JobService/AddJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).AddJob(ctx, req.(*Job))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_GetByIdJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).GetByIdJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.JobService/GetByIdJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).GetByIdJob(ctx, req.(*JobId))
	}
	return interceptor(ctx, in, info, handler)
}

var _JobService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "model.JobService",
	HandlerType: (*JobServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllJob",
			Handler:    _JobService_GetAllJob_Handler,
		},
		{
			MethodName: "AddJob",
			Handler:    _JobService_AddJob_Handler,
		},
		{
			MethodName: "GetByIdJob",
			Handler:    _JobService_GetByIdJob_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "master.proto",
}

// CompetencyServiceClient is the client API for CompetencyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CompetencyServiceClient interface {
	GetAllCompetency(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CompetencyList, error)
	DeleteJobById(ctx context.Context, in *JobId, opts ...grpc.CallOption) (*Response, error)
	GetCompetencyById(ctx context.Context, in *CompId, opts ...grpc.CallOption) (*Competencies, error)
	GetCompetencyByJobId(ctx context.Context, in *CompId, opts ...grpc.CallOption) (*CompetencyList, error)
}

type competencyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCompetencyServiceClient(cc grpc.ClientConnInterface) CompetencyServiceClient {
	return &competencyServiceClient{cc}
}

func (c *competencyServiceClient) GetAllCompetency(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*CompetencyList, error) {
	out := new(CompetencyList)
	err := c.cc.Invoke(ctx, "/model.CompetencyService/GetAllCompetency", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *competencyServiceClient) DeleteJobById(ctx context.Context, in *JobId, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/model.CompetencyService/DeleteJobById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *competencyServiceClient) GetCompetencyById(ctx context.Context, in *CompId, opts ...grpc.CallOption) (*Competencies, error) {
	out := new(Competencies)
	err := c.cc.Invoke(ctx, "/model.CompetencyService/GetCompetencyById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *competencyServiceClient) GetCompetencyByJobId(ctx context.Context, in *CompId, opts ...grpc.CallOption) (*CompetencyList, error) {
	out := new(CompetencyList)
	err := c.cc.Invoke(ctx, "/model.CompetencyService/GetCompetencyByJobId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CompetencyServiceServer is the server API for CompetencyService service.
// All implementations must embed UnimplementedCompetencyServiceServer
// for forward compatibility
type CompetencyServiceServer interface {
	GetAllCompetency(context.Context, *Empty) (*CompetencyList, error)
	DeleteJobById(context.Context, *JobId) (*Response, error)
	GetCompetencyById(context.Context, *CompId) (*Competencies, error)
	GetCompetencyByJobId(context.Context, *CompId) (*CompetencyList, error)
	mustEmbedUnimplementedCompetencyServiceServer()
}

// UnimplementedCompetencyServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCompetencyServiceServer struct {
}

func (UnimplementedCompetencyServiceServer) GetAllCompetency(context.Context, *Empty) (*CompetencyList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllCompetency not implemented")
}
func (UnimplementedCompetencyServiceServer) DeleteJobById(context.Context, *JobId) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteJobById not implemented")
}
func (UnimplementedCompetencyServiceServer) GetCompetencyById(context.Context, *CompId) (*Competencies, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCompetencyById not implemented")
}
func (UnimplementedCompetencyServiceServer) GetCompetencyByJobId(context.Context, *CompId) (*CompetencyList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCompetencyByJobId not implemented")
}
func (UnimplementedCompetencyServiceServer) mustEmbedUnimplementedCompetencyServiceServer() {}

// UnsafeCompetencyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CompetencyServiceServer will
// result in compilation errors.
type UnsafeCompetencyServiceServer interface {
	mustEmbedUnimplementedCompetencyServiceServer()
}

func RegisterCompetencyServiceServer(s grpc.ServiceRegistrar, srv CompetencyServiceServer) {
	s.RegisterService(&_CompetencyService_serviceDesc, srv)
}

func _CompetencyService_GetAllCompetency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompetencyServiceServer).GetAllCompetency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.CompetencyService/GetAllCompetency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompetencyServiceServer).GetAllCompetency(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompetencyService_DeleteJobById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompetencyServiceServer).DeleteJobById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.CompetencyService/DeleteJobById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompetencyServiceServer).DeleteJobById(ctx, req.(*JobId))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompetencyService_GetCompetencyById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompetencyServiceServer).GetCompetencyById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.CompetencyService/GetCompetencyById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompetencyServiceServer).GetCompetencyById(ctx, req.(*CompId))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompetencyService_GetCompetencyByJobId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompetencyServiceServer).GetCompetencyByJobId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/model.CompetencyService/GetCompetencyByJobId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompetencyServiceServer).GetCompetencyByJobId(ctx, req.(*CompId))
	}
	return interceptor(ctx, in, info, handler)
}

var _CompetencyService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "model.CompetencyService",
	HandlerType: (*CompetencyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllCompetency",
			Handler:    _CompetencyService_GetAllCompetency_Handler,
		},
		{
			MethodName: "DeleteJobById",
			Handler:    _CompetencyService_DeleteJobById_Handler,
		},
		{
			MethodName: "GetCompetencyById",
			Handler:    _CompetencyService_GetCompetencyById_Handler,
		},
		{
			MethodName: "GetCompetencyByJobId",
			Handler:    _CompetencyService_GetCompetencyByJobId_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "master.proto",
}
